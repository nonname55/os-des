# 1.订单优先级计算函数

## 场景

骑手需要以一定的顺序去送当前已经接受的订单，而这个顺序的决定方式就是根据订单的优先级排序，所以需要一个函数计算订单的优先级

骑手会先送优先级高的订单

## 示例

在Rider结构体中有这样一个函数

```cpp
double H(const Order& order) {
    int dis = graph.astar(posx, posy, order.tarx, order.tary, false);
    double disH = 1.0 / dis;
    double timeH = 1.0 / order.required_time;
    return 0.3 * disH + 0.7 * timeH;
};
```

在示例中，dis就是骑手当前位置到订单位置的距离，required_time是订单要求送达的时间，dis越小，required_time越小，优先级越高，并且距离权重占总优先级0.3的比重，要求时间占0.7的比重

## 要求

函数接收一个Order结构体（订单），返回参数订单的优先级值（double或其他类型）

需要尽可能科学的设计出这个函数，以保证根据每个订单返回的优先级排序之后，骑手运送的路线较为合理

# 2.判断是否抢单

## 改进建议
1. 加入对超时订单数量的考虑。如果算出当前订单不会超时，但接了这个单会导致更多其他订单超时，那肯定还是不接这个单比较好
2. 目前有饭店做饭的过程，也就是说在计算送订单时间的时候，不能单纯的考虑走过去的时间，还有骑手到店等待饭做好的时间。有关函数我已经写好了，可以查看主页

## 提示
目前，取餐和送餐是分割开的，就是说骑手可能连续到几个饭店去取餐然后再去送（而不是像以前一样取餐送餐为一个整体）。

Order结构体中的`is_take`为true时是已经取餐，false为还没有取餐