# 1.订单优先级计算函数

## 场景

骑手需要以一定的顺序去送当前已经接受的订单，而这个顺序的决定方式就是根据订单的优先级排序，所以需要一个函数计算订单的优先级

骑手会先送优先级高的订单

## 示例

在Rider结构体中有这样一个函数

```cpp
double H(const Order& order) {
    int dis = graph.astar(posx, posy, order.tarx, order.tary, false);
    double disH = 1.0 / dis;
    double timeH = 1.0 / order.required_time;
    return 0.3 * disH + 0.7 * timeH;
};
```

在示例中，dis就是骑手当前位置到订单位置的距离，required_time是订单要求送达的时间，dis越小，required_time越小，优先级越高，并且距离权重占总优先级0.3的比重，要求时间占0.7的比重

## 要求

函数接收一个Order结构体（订单），返回参数订单的优先级值（double或其他类型）

需要尽可能科学的设计出这个函数，以保证根据每个订单返回的优先级排序之后，骑手运送的路线较为合理

# 2.判断是否抢单

## 场景

会有一些订单没有被任何骑手接收，这时骑手会访问所有这样的订单，并对每个订单判断一下要不要接

因为还没有完成与商家、顾客的对接，所以目前的代码中并没有相关内容

## 要求

写一个函数，接收一个Order结构体作为参数，返回一个bool表示这个订单要不要接

类似：

```cpp
bool function(const Order& order) {
    ...
}
```

只需要写这个函数就行

## 提示

骑手已经接了的订单是放在Rider结构体中的一个成员变量中：

```cpp
std::deque<std::shared_ptr<Order>> orders;
```

可以先把orders这个拷贝一份，然后计算出新订单的优先级后，将新订单加入拷贝后的orders并排序，计算出什么时候会送到这个新订单，如果发现不会超时，那就接单，如果会超时但是超的不多，也可以接单，否则不接单